#############################################################
#
# Template for the Moxa E1214 module:
#   6 DIs
#   6 relays
#
# Macros:
# P - base PV name
# R - module PV name
# PORT - asyn port name (modbus TCP)
# IP_PORT - the low level IP port name (used for drvAsynIPPortConfigure)
# ADDR - asyn address (defaults to 0)
# 
# Matt Pearson
# Feb 2019
#
#############################################################

# ///
# /// Generic Asyn record.
# /// Not useful for modbus params, but we can see the 
# /// socket connect status via the CNCT field
# ///
record(asyn,"$(P)$(R)Asyn") {
  field(DTYP,"asynRecordDevice")
  field(PORT,"$(IP_PORT)")
  field(ADDR,"$(ADDR=0)")
}
record(bi, "$(P)$(R)Connected") {
  field(INP, "$(P)$(R)Asyn.CNCT CP")
  field(ZNAM, "Disconnected")
  field(ONAM, "Connected")
  field(ZSV, "MAJOR")
}

##############################################################
# The following records are processed once at startup, or 
# when we connect. They use absolute modbus addressing so we 
# don't poll these.

# ///
# /// Model name
# ///
record(waveform, "$(P)$(R)ModelName") {
  field(NELM, "21")
  field(FTVL, "CHAR")
  field(DTYP, "asynOctetRead")
  field(INP, "@asyn($(PORT)10w,5000,1)STRING_HIGH_LOW")
  field(SCAN, "Passive")
}

# ///
# /// Read the MAC address into two ints, since it's in 6 bytes, then split up.
# /// Remove the sign bit on the high order byte, and add it back on again
# /// after bitshifting, so we don't end up with a negative number.
# ///
record(longin, "$(P)$(R)MAC") {
  field(DTYP, "asynInt32")
  field(INP, "@asyn($(PORT)2w,5024,1)INT32_BE")
  field(SCAN, "Passive")
  field(FLNK, "$(P)$(R)MAC_2")
}
record(longin, "$(P)$(R)MAC_2") {
  field(DTYP, "asynInt32")
  field(INP, "@asyn($(PORT)2w,5025,1)INT32_BE")
  field(SCAN, "Passive")
  field(FLNK, "$(P)$(R)MAC1")
}
record(calc, "$(P)$(R)MAC1") {
  field(INPA, "$(P)$(R)MAC")
  field(CALC, "A<0?((A&0x7F000000)>>24)|0x80:((A&0xFF000000)>>24)")
  field(FLNK, "$(P)$(R)MAC2")
}
record(calc, "$(P)$(R)MAC2") {
  field(INPA, "$(P)$(R)MAC")
  field(CALC, "((A&0x00FF0000)>>16)")
  field(FLNK, "$(P)$(R)MAC3")
}
record(calc, "$(P)$(R)MAC3") {
  field(INPA, "$(P)$(R)MAC")
  field(CALC, "((A&0x0000FF00)>>8)")
  field(FLNK, "$(P)$(R)MAC4")
}
record(calc, "$(P)$(R)MAC4") {
  field(INPA, "$(P)$(R)MAC")
  field(CALC, "(A&0x000000FF)")
  field(FLNK, "$(P)$(R)MAC5")
}
record(calc, "$(P)$(R)MAC5") {
  field(INPA, "$(P)$(R)MAC_2")
  field(CALC, "((A&0x0000FF00)>>8)")
  field(FLNK, "$(P)$(R)MAC6")
}
record(calc, "$(P)$(R)MAC6") {
  field(INPA, "$(P)$(R)MAC_2")
  field(CALC, "(A&0x000000FF)")
}

# ///
# /// Read the IP address into an int, then split up.
# /// Remove the sign bit on the high order byte, and add it back on again
# /// after bitshifting, so we don't end up with a negative number.
# ///
record(longin, "$(P)$(R)IP") {
  field(DTYP, "asynInt32")
  field(INP, "@asyn($(PORT)2w,5027,1)INT32_BE")
  field(SCAN, "Passive")
  field(FLNK, "$(P)$(R)IP1")
}
record(calc, "$(P)$(R)IP1") {
  field(INPA, "$(P)$(R)IP")
  field(CALC, "A<0?((A&0x7F000000)>>24)|0x80:((A&0xFF000000)>>24)")
  field(FLNK, "$(P)$(R)IP2")
}
record(calc, "$(P)$(R)IP2") {
  field(INPA, "$(P)$(R)IP")
  field(CALC, "((A&0x00FF0000)>>16)")
  field(FLNK, "$(P)$(R)IP3")
}
record(calc, "$(P)$(R)IP3") {
  field(INPA, "$(P)$(R)IP")
  field(CALC, "((A&0x0000FF00)>>8)")
  field(FLNK, "$(P)$(R)IP4")
}
record(calc, "$(P)$(R)IP4") {
  field(INPA, "$(P)$(R)IP")
  field(CALC, "(A&0x000000FF)")
}

# ///
# /// Firmware build date
# ///
record(longin, "$(P)$(R)FWB") {
  field(DTYP, "asynInt32")
  field(INP, "@asyn($(PORT)2w,5031,1)INT32_BE")
  field(SCAN, "Passive")
  field(FLNK, "$(P)$(R)FWBYear")
}
record(calc, "$(P)$(R)FWBYear") {
  field(INPA, "$(P)$(R)FWB")
  field(CALC, "A<0?((A&0x7F000000)>>24)|0x80:((A&0xFF000000)>>24)")
  field(FLNK, "$(P)$(R)FWBMonth")
}
record(calc, "$(P)$(R)FWBMonth") {
  field(INPA, "$(P)$(R)FWB")
  field(CALC, "((A&0x00FF0000)>>16)")
  field(FLNK, "$(P)$(R)FWBDay")
}
record(calc, "$(P)$(R)FWBDay") {
  field(INPA, "$(P)$(R)FWB")
  field(CALC, "((A&0x0000FF00)>>8)")
}

# ///
# /// Firmware version
# ///
record(longin, "$(P)$(R)FWV") {
  field(DTYP, "asynInt32")
  field(INP, "@asyn($(PORT)2w,5029,1)INT32_BE")
  field(SCAN, "Passive")
  field(FLNK, "$(P)$(R)FWV1")
}
record(calc, "$(P)$(R)FWV1") {
  field(INPA, "$(P)$(R)FWV")
  field(CALC, "A<0?((A&0x7F000000)>>24)|0x80:((A&0xFF000000)>>24)")
  field(FLNK, "$(P)$(R)FWV2")
}
record(calc, "$(P)$(R)FWV2") {
  field(INPA, "$(P)$(R)FWV")
  field(CALC, "((A&0x00FF0000)>>16)")
  field(FLNK, "$(P)$(R)FWV3")
}
record(calc, "$(P)$(R)FWV3") {
  field(INPA, "$(P)$(R)FWV")
  field(CALC, "((A&0x0000FF00)>>8)")
}

# ///
# /// Device name. This can be user defined and set via the web page.
# ///
record(waveform, "$(P)$(R)DeviceName") {
  field(NELM, "61")
  field(FTVL, "CHAR")
  field(DTYP, "asynOctetRead")
  field(INP, "@asyn($(PORT)30w,5040,1)STRING_HIGH_LOW")
  field(SCAN, "Passive")
}

# ///
# /// Read some information once at startup, and when we reconnect.
# ///
record(dfanout, "$(P)$(R)InfoRead") {
  field(PINI, "YES")
  field(VAL, "1")
  field(OUTA, "$(P)$(R)ModelName.PROC PP")
  field(OUTB, "$(P)$(R)MAC.PROC PP")
  field(OUTC, "$(P)$(R)IP.PROC PP")
  field(OUTD, "$(P)$(R)FWB.PROC PP")
  field(OUTE, "$(P)$(R)FWV.PROC PP")
  field(OUTF, "$(P)$(R)DeviceName.PROC PP")
}

record(calcout, "$(P)$(R)InfoReadCalc") {
  field(INPA, "$(P)$(R)Connected CP")
  field(CALC, "A=1")
  field(OOPT, "Transition To Non-zero")
  field(DOPT, "Use CALC")
  field(OUT, "$(P)$(R)InfoRead.PROC PP")
}

########################################################
# Polling functions

# ///
# /// Device uptime
# ///
record(longin, "$(P)$(R)Uptime") {
  field(DESC, "Device Uptime")
  field(DTYP, "asynInt32")
  field(INP, "@asyn($(PORT)2w,5020,1)INT32_BE")
  field(SCAN, "1 second")
}

# ///
# /// Watchdog
# ///
record(bi, "$(P)$(R)Watchdog") {
  field(DESC, "Watchdog")
  field(DTYP, "asynInt32")
  field(INP, "@asyn($(PORT)1b,4144,1)")
  field(SCAN, "1 second")
  field(ZNAM, "OK")
  field(ONAM, "Alarm")
  field(OSV, "MAJOR")
}

# ///
# /// All digital inputs (1-6)
# ///
#record(mbbiDirect, "$(P)$(R)DI") {
#  field(DESC, "All DI")
#  field(DTYP, "asynInt32")
#  field(INP, "@asyn($(PORT)dir,0,1)")
#  field(SCAN, "I/O Intr")
#}
#record(bi, "$(P)$(R)DI2") {
#  field(INP, "$(P)$(R)DI.B1 CP MS")
#  field(ZNAM, "Off")
#  field(ONAM, "On")
#}
#record(bi, "$(P)$(R)DI3") {
#  field(INP, "$(P)$(R)DI.B2 CP MS")
#  field(ZNAM, "Off")
#  field(ONAM, "On")
#}
#record(bi, "$(P)$(R)DI4") {
#  field(INP, "$(P)$(R)DI.B3 CP MS")
#  field(ZNAM, "Off")
#  field(ONAM, "On")
#}
#record(bi, "$(P)$(R)DI5") {
#  field(INP, "$(P)$(R)DI.B4 CP MS")
#  field(ZNAM, "Off")
#  field(ONAM, "On")
#}
#record(bi, "$(P)$(R)DI6") {
#  field(INP, "$(P)$(R)DI.B5 CP MS")
#  field(ZNAM, "Off")
#  field(ONAM, "On")
#}
#record(bi, "$(P)$(R)DI1") {
#  field(INP, "$(P)$(R)DI.B0 CP MS")
#  field(ZNAM, "Off")
#  field(ONAM, "On")
#}

# ///
# /// All relay status (1-6)
# ///
#record(mbbiDirect, "$(P)$(R)RLY") {
#  field(DESC, "All Relays")
#  field(DTYP, "asynInt32")
#  field(INP, "@asyn($(PORT)rlyr,0,1)")
#  field(SCAN, "I/O Intr")
#}
#record(bi, "$(P)$(R)RLY1") {
#  field(INP, "$(P)$(R)RLY.B0 CP MS")
#  field(ZNAM, "Off")
#  field(ONAM, "On")
#}
#record(bi, "$(P)$(R)RLY2") {
#  field(INP, "$(P)$(R)RLY.B1 CP MS")
#  field(ZNAM, "Off")
#  field(ONAM, "On")
#}
#record(bi, "$(P)$(R)RLY3") {
#  field(INP, "$(P)$(R)RLY.B2 CP MS")
#  field(ZNAM, "Off")
#  field(ONAM, "On")
#}
#record(bi, "$(P)$(R)RLY4") {
#  field(INP, "$(P)$(R)RLY.B3 CP MS")
#  field(ZNAM, "Off")
#  field(ONAM, "On")
#}
#record(bi, "$(P)$(R)RLY5") {
#  field(INP, "$(P)$(R)RLY.B4 CP MS")
#  field(ZNAM, "Off")
#  field(ONAM, "On")
#}
#record(bi, "$(P)$(R)RLY6") {
#  field(INP, "$(P)$(R)RLY.B5 CP MS")
#  field(ZNAM, "Off")
#  field(ONAM, "On")
#}

###########################################################
# Write functions

# ///
# /// Process this to clear an active watchdog
# ///
#record(bo, "$(P)$(R)WatchdogReset") {
#  field(VAL, "1")
#  field(DTYP, "asynInt32")
#  field(OUT, "@asyn($(PORT)ww,0,1)")
#}

# ///
# /// Set the relay status
# ///
#record(bo, "$(P)$(R)RLY1Set") {
#  field(ZNAM, "Off")
#  field(ONAM, "On")
#  field(OUT, "@asyn($(PORT)rlyw,0,1)")
#}
#record(bo, "$(P)$(R)RLY2Set") {
#  field(ZNAM, "Off")
#  field(ONAM, "On")
#  field(OUT, "@asyn($(PORT)rlyw,1,1)")
#}
#record(bo, "$(P)$(R)RLY3Set") {
#  field(ZNAM, "Off")
#  field(ONAM, "On")
#  field(OUT, "@asyn($(PORT)rlyw,2,1)")
#}
#record(bo, "$(P)$(R)RLY4Set") {
#  field(ZNAM, "Off")
#  field(ONAM, "On")
#  field(OUT, "@asyn($(PORT)rlyw,3,1)")
#}
#record(bo, "$(P)$(R)RLY5Set") {
#  field(ZNAM, "Off")
#  field(ONAM, "On")
#  field(OUT, "@asyn($(PORT)rlyw,4,1)")
#}
#record(bo, "$(P)$(R)RLY6Set") {
#  field(ZNAM, "Off")
#  field(ONAM, "On")
#  field(OUT, "@asyn($(PORT)rlyw,5,1)")
#}



