#############################################################
#
# Template for the Moxa E1214 module:
#   6 DIs
#   6 relays
#
# Macros:
# P - base PV name
# R - module PV name
# PORT - asyn port name (modbus TCP)
# IP_PORT - the low level IP port name (used for drvAsynIPPortConfigure)
# ADDR - asyn address (defaults to 0)
# 
# Matt Pearson
# Feb 2019
#
#############################################################

# ///
# /// Generic Asyn record.
# /// Not useful for modbus params, but we can see the 
# /// socket connect status via the CNCT field
# ///
record(asyn,"$(P)$(R)Asyn") {
  field(DTYP,"asynRecordDevice")
  field(PORT,"$(IP_PORT)")
  field(ADDR,"$(ADDR=0)")
}
record(bi, "$(P)$(R)Connected") {
  field(INP, "$(P)$(R)Asyn.CNCT CP")
  field(ZNAM, "Disconnected")
  field(ONAM, "Connected")
  field(ZSV, "MAJOR")
}

##############################################################
# The following records are processed once at startup, or 
# when we connect. They use absolute modbus addressing so we 
# don't poll these.

# ///
# /// Model name
# ///
record(waveform, "$(P)$(R)ModelName") {
  field(NELM, "21")
  field(FTVL, "CHAR")
  field(DTYP, "asynOctetRead")
  field(INP, "@asyn($(PORT)10w4,5000,1)STRING_HIGH_LOW")
  field(SCAN, "Passive")
}

# ///
# /// Read the MAC address into two ints, since it's in 6 bytes, then split up.
# /// Remove the sign bit on the high order byte, and add it back on again
# /// after bitshifting, so we don't end up with a negative number.
# ///
record(longin, "$(P)$(R)MAC") {
  field(DTYP, "asynInt32")
  field(INP, "@asyn($(PORT)2w4,5024,1)INT32_BE")
  field(SCAN, "Passive")
  field(FLNK, "$(P)$(R)MAC_2")
}
record(longin, "$(P)$(R)MAC_2") {
  field(DTYP, "asynInt32")
  field(INP, "@asyn($(PORT)2w4,5025,1)INT32_BE")
  field(SCAN, "Passive")
  field(FLNK, "$(P)$(R)MAC1")
}
record(calc, "$(P)$(R)MAC1") {
  field(INPA, "$(P)$(R)MAC")
  field(CALC, "A<0?((A&0x7F000000)>>24)|0x80:((A&0xFF000000)>>24)")
  field(FLNK, "$(P)$(R)MAC2")
}
record(calc, "$(P)$(R)MAC2") {
  field(INPA, "$(P)$(R)MAC")
  field(CALC, "((A&0x00FF0000)>>16)")
  field(FLNK, "$(P)$(R)MAC3")
}
record(calc, "$(P)$(R)MAC3") {
  field(INPA, "$(P)$(R)MAC")
  field(CALC, "((A&0x0000FF00)>>8)")
  field(FLNK, "$(P)$(R)MAC4")
}
record(calc, "$(P)$(R)MAC4") {
  field(INPA, "$(P)$(R)MAC")
  field(CALC, "(A&0x000000FF)")
  field(FLNK, "$(P)$(R)MAC5")
}
record(calc, "$(P)$(R)MAC5") {
  field(INPA, "$(P)$(R)MAC_2")
  field(CALC, "((A&0x0000FF00)>>8)")
  field(FLNK, "$(P)$(R)MAC6")
}
record(calc, "$(P)$(R)MAC6") {
  field(INPA, "$(P)$(R)MAC_2")
  field(CALC, "(A&0x000000FF)")
}

# ///
# /// Read the IP address into an int, then split up.
# /// Remove the sign bit on the high order byte, and add it back on again
# /// after bitshifting, so we don't end up with a negative number.
# ///
record(longin, "$(P)$(R)IP") {
  field(DTYP, "asynInt32")
  field(INP, "@asyn($(PORT)2w4,5027,1)INT32_BE")
  field(SCAN, "Passive")
  field(FLNK, "$(P)$(R)IP1")
}
record(calc, "$(P)$(R)IP1") {
  field(INPA, "$(P)$(R)IP")
  field(CALC, "A<0?((A&0x7F000000)>>24)|0x80:((A&0xFF000000)>>24)")
  field(FLNK, "$(P)$(R)IP2")
}
record(calc, "$(P)$(R)IP2") {
  field(INPA, "$(P)$(R)IP")
  field(CALC, "((A&0x00FF0000)>>16)")
  field(FLNK, "$(P)$(R)IP3")
}
record(calc, "$(P)$(R)IP3") {
  field(INPA, "$(P)$(R)IP")
  field(CALC, "((A&0x0000FF00)>>8)")
  field(FLNK, "$(P)$(R)IP4")
}
record(calc, "$(P)$(R)IP4") {
  field(INPA, "$(P)$(R)IP")
  field(CALC, "(A&0x000000FF)")
}

# ///
# /// Firmware build date
# ///
record(longin, "$(P)$(R)FWB") {
  field(DTYP, "asynInt32")
  field(INP, "@asyn($(PORT)2w4,5031,1)INT32_BE")
  field(SCAN, "Passive")
  field(FLNK, "$(P)$(R)FWBYear")
}
record(calc, "$(P)$(R)FWBYear") {
  field(INPA, "$(P)$(R)FWB")
  field(CALC, "A<0?((A&0x7F000000)>>24)|0x80:((A&0xFF000000)>>24)")
  field(FLNK, "$(P)$(R)FWBMonth")
}
record(calc, "$(P)$(R)FWBMonth") {
  field(INPA, "$(P)$(R)FWB")
  field(CALC, "((A&0x00FF0000)>>16)")
  field(FLNK, "$(P)$(R)FWBDay")
}
record(calc, "$(P)$(R)FWBDay") {
  field(INPA, "$(P)$(R)FWB")
  field(CALC, "((A&0x0000FF00)>>8)")
}

# ///
# /// Firmware version
# ///
record(longin, "$(P)$(R)FWV") {
  field(DTYP, "asynInt32")
  field(INP, "@asyn($(PORT)2w4,5029,1)INT32_BE")
  field(SCAN, "Passive")
  field(FLNK, "$(P)$(R)FWV1")
}
record(calc, "$(P)$(R)FWV1") {
  field(INPA, "$(P)$(R)FWV")
  field(CALC, "A<0?((A&0x7F000000)>>24)|0x80:((A&0xFF000000)>>24)")
  field(FLNK, "$(P)$(R)FWV2")
}
record(calc, "$(P)$(R)FWV2") {
  field(INPA, "$(P)$(R)FWV")
  field(CALC, "((A&0x00FF0000)>>16)")
  field(FLNK, "$(P)$(R)FWV3")
}
record(calc, "$(P)$(R)FWV3") {
  field(INPA, "$(P)$(R)FWV")
  field(CALC, "((A&0x0000FF00)>>8)")
}

# ///
# /// Device name. This can be user defined and set via the web page.
# ///
record(waveform, "$(P)$(R)DeviceName") {
  field(NELM, "61")
  field(FTVL, "CHAR")
  field(DTYP, "asynOctetRead")
  field(INP, "@asyn($(PORT)30w4,5040,1)STRING_HIGH_LOW")
  field(SCAN, "Passive")
}

# ///
# /// Read some information once at startup, and when we reconnect.
# ///
record(dfanout, "$(P)$(R)InfoRead") {
  field(PINI, "YES")
  field(VAL, "1")
  field(OUTA, "$(P)$(R)ModelName.PROC PP")
  field(OUTB, "$(P)$(R)MAC.PROC PP")
  field(OUTC, "$(P)$(R)IP.PROC PP")
  field(OUTD, "$(P)$(R)FWB.PROC PP")
  field(OUTE, "$(P)$(R)FWV.PROC PP")
  field(OUTF, "$(P)$(R)DeviceName.PROC PP")
}

record(calcout, "$(P)$(R)InfoReadCalc") {
  field(INPA, "$(P)$(R)Connected CP")
  field(CALC, "A=1")
  field(OOPT, "Transition To Non-zero")
  field(DOPT, "Use CALC")
  field(OUT, "$(P)$(R)InfoRead.PROC PP")
}

########################################################
# Polling functions

# ///
# /// Device uptime
# ///
record(longin, "$(P)$(R)Uptime") {
  field(DESC, "Device Uptime")
  field(DTYP, "asynInt32")
  field(INP, "@asyn($(PORT)2w4,5020,1)INT32_BE")
  field(SCAN, "1 second")
}

# ///
# /// Watchdog
# ///
record(bi, "$(P)$(R)Watchdog") {
  field(DESC, "Watchdog")
  field(DTYP, "asynInt32")
  field(INP, "@asyn($(PORT)1b1,4144,1)")
  field(SCAN, "1 second")
  field(ZNAM, "OK")
  field(ONAM, "Alarm")
  field(OSV, "MAJOR")
}

# ///
# /// All digital inputs (1-6)
# ///
record(mbbiDirect, "$(P)$(R)DI") {
  field(DESC, "All DI")
  field(DTYP, "asynUInt32Digital")
  field(INP, "@asynMask($(PORT)1w4,48,0x003F,1)INT32_BE")
  field(SCAN, ".1 second")
  field(FLNK, "$(P)$(R)DI0")
}
record(bi, "$(P)$(R)DI0") {
  field(INP, "$(P)$(R)DI.B0 MS")
  field(ZNAM, "Off")
  field(ONAM, "On")
  field(FLNK, "$(P)$(R)DI1")
}
record(bi, "$(P)$(R)DI1") {
  field(INP, "$(P)$(R)DI.B1 MS")
  field(ZNAM, "Off")
  field(ONAM, "On")
  field(FLNK, "$(P)$(R)DI2")
}
record(bi, "$(P)$(R)DI2") {
  field(INP, "$(P)$(R)DI.B2 MS")
  field(ZNAM, "Off")
  field(ONAM, "On")
  field(FLNK, "$(P)$(R)DI3")
}
record(bi, "$(P)$(R)DI3") {
  field(INP, "$(P)$(R)DI.B3 MS")
  field(ZNAM, "Off")
  field(ONAM, "On")
  field(FLNK, "$(P)$(R)DI4")
}
record(bi, "$(P)$(R)DI4") {
  field(INP, "$(P)$(R)DI.B4 MS")
  field(ZNAM, "Off")
  field(ONAM, "On")
  field(FLNK, "$(P)$(R)DI5")
}
record(bi, "$(P)$(R)DI5") {
  field(INP, "$(P)$(R)DI.B5 MS")
  field(ZNAM, "Off")
  field(ONAM, "On")
}


# ///
# /// All relay status (1-6)
# ///
record(mbbiDirect, "$(P)$(R)RLY") {
  field(DESC, "All Relays")
  field(DTYP, "asynUInt32Digital")
  field(INP, "@asynMask($(PORT)1w3,32,0x003F,1)INT32_BE")
  field(SCAN, ".1 second")
  field(FLNK, "$(P)$(R)RLY0")
}
record(bi, "$(P)$(R)RLY0") {
  field(INP, "$(P)$(R)RLY.B0 MS")
  field(ZNAM, "Off")
  field(ONAM, "On")
  field(FLNK, "$(P)$(R)RLY1")
}
record(bi, "$(P)$(R)RLY1") {
  field(INP, "$(P)$(R)RLY.B1 MS")
  field(ZNAM, "Off")
  field(ONAM, "On")
  field(FLNK, "$(P)$(R)RLY2")
}
record(bi, "$(P)$(R)RLY2") {
  field(INP, "$(P)$(R)RLY.B2 MS")
  field(ZNAM, "Off")
  field(ONAM, "On")
  field(FLNK, "$(P)$(R)RLY3")
}
record(bi, "$(P)$(R)RLY3") {
  field(INP, "$(P)$(R)RLY.B3 MS")
  field(ZNAM, "Off")
  field(ONAM, "On")
  field(FLNK, "$(P)$(R)RLY4")
}
record(bi, "$(P)$(R)RLY4") {
  field(INP, "$(P)$(R)RLY.B4 MS")
  field(ZNAM, "Off")
  field(ONAM, "On")
  field(FLNK, "$(P)$(R)RLY5")
}
record(bi, "$(P)$(R)RLY5") {
  field(INP, "$(P)$(R)RLY.B5 MS")
  field(ZNAM, "Off")
  field(ONAM, "On")
}

###########################################################
# Write functions

# ///
# /// Process this to clear an active watchdog
# /// This has not been tested because I'm not sure how to generate a watchdog.
# ///
record(bo, "$(P)$(R)WatchdogReset") {
  field(VAL, "1")
  field(DTYP, "asynInt32")
  field(OUT, "@asyn($(PORT)1b5,4144,1)")
}

# ///
# /// Set the relay status. This can be done by
# /// setting the bits (B0-B5). To turn off all the 
# /// relays the set the VAL to 0.
# ///
record(mbboDirect, "$(P)$(R)RLYSet") {
  field(DESC, "Set All Relays")
  field(DTYP, "asynUInt32Digital")
  field(OUT, "@asynMask($(PORT)1w6,32,0x003F,1)INT32_BE")
}





